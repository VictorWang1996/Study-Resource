## 一.计算机网络
### 1.get请求和post请求的区别




> 1、GET请求一般用去请求获取数据，POST一般作为发送数据到后台时使用    
2、GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的  
  POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制  
3、GET请求刷新浏览器或回退时没有影响,POST回退时会重新提交数据请求  
4、GET 请求可被缓存,POST 请求不会被缓存  
5、GET 请求保留在浏览器历史记录中,POST 请求不会保留在浏览器历史记录中  
6、GET 请求可被收藏为书签,POST 不能被收藏为书签  
7、GET请求只能进行url编码（application/x-www-form-urlencoded）  
  POST支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。）  
8、GET请求比较常见的方式是通过url地址栏请求,POST最常见是通过form表单发送数据请求  
9.GET产生一个TCP数据包；POST产生两个TCP数据包  
长的说：  
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；  
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。  
也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。  

### 2.在浏览器网址输入一个url后直到浏览器显示页面的过程(这边面试官可能会详细的考察DNS服务器的知识)
> **一、网络通信**  
> 互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。  
> **TCP/IP**  
> 1.在浏览器中输入url
> 用户输入url，例如http://www.baidu.com。 其中http为协议，www.baidu.com 为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。  
> 2.应用层DNS解析域名  
>    客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。  
> **DNS中递归查询和迭代查询的区别**  
> 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。  
> 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。  
> 以一个DNS请求解析为例：  
> 1）用户发起域名请求到dnsA，这时dnsA有这个记录，将结果返回给用户，这个过程是递归查询。  
> 2）用户发起域名请求到dnsA，这时dns没有这个记录，它去向dnsB问有没有这个记录，以此类推，直到把结果返回给用户，这个过程是递归查询。  
> 3）用户发起域名请求到dnsA，这时dnsA没有这个记录，它告诉用户，我没有这个记录，你去问dnsB吧，这个过程是迭代查询。  
> 3.应用层客户端发送HTTP请求  
> HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。  
> 4.传输层TCP传输报文  
>    位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。
>   “三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。  
> **TCP**  
> 5.网络层IP协议查询MAC地址
>   IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一中转目标。  
> 6.数据到达数据链路层  
>   在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束  
> 7.服务器接收数据  
>   接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。  
> 8.服务器响应请求  
>   服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。    
> 9.服务器返回相应文件  
>   请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。   
> **二、页面渲染**  
>    现代浏览器渲染页面的过程是这样的：jiexiHTML以构建DOM树 –构建渲染树 –布局渲染树 –绘制渲染树。
>    DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像<head>元素或display属性值为none的元素都不在渲染树中。
>    在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。  
### 3.tcp三次握手和四次挥手的过程(为什么不可以两次握手，为什么握手要三次，挥手需要四次)   ###
> **三次握手**
> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
> 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”
**四次挥手**
> 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
> 由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。
### 4.七层OSI模型或TCP/IP协议模型(各层分别实现了什么协议)   ###

|OSI中的层|功能TCP|IP协议族|  
| --- | --- | --- |  
|应用层|文件传输，电子邮件，文件服务，虚拟终端|TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet|  
|表示层|	数据格式化，代码转换，数据加密|	无|  
|会话层|	控制应用程序之间会话能力；如不同软件数据分发给不同软件	|ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets|  
|传输层|	端到端传输数据的基本功能|TCP、UDP|  
|网络层|	定义IP编址，定义路由功能；如不同设备的数据转发|IP，ICMP，RIP，OSPF，BGP，IGMP|  
|数据链路层|定义数据的基本格式，如何传输，如何标识|SLIP，CSLIP，PPP，ARP，RARP，MTU|  
|物理层|以二进制数据形式在物理媒体上传输数据|ISO2110，IEEE802|
### 5.各种io模型的知识(BIO,NIO,AIO)   ###

> **BIO** 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。（一连接一线程）  
**NIO** 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。  
![](https://img-blog.csdnimg.cn/20190422121139668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA5MDQ2,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20190422121151244.png)
**AIO** 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。  
### 6.http协议和tcp协议的区别  

> TCP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
TCP协议对应传输层，，而HTTP协议对应应用层，从本质上说，Http协议是建立在TCP协议基础之上的。当浏览器需要从服务器 获取网页数据的时候，会发出一次http请求。Http通过TCP建立起一个到服务器的通道。简单的说，当一个网页完成之后，客户端和服务器端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个页面时，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间，Http是无状态的连接，TCP是有状态的长连接。
### 7.https和http的区别
> https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
> http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
> http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
> http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
### 8.https的请求过程   ###
![](https://mmbiz.qpic.cn/mmbiz_jpg/FIXT5d3vGcpUvnYVlGTOia56vzkkfpOzsSUH8DWIV0lPWBiamYMAAGU9sGEiaS163Tglica6BT2ZPLHeBjtx7gxuCg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
### 9.http协议的发展历程

> **HTTP/0.9**   
HTTP协议的最初版本，功能简陋，仅支持 GET 方法，并且仅能请求访问 HTML 格式的资源  
**HTTP/1.0**  
增加了请求方式 POST 和 HEAD  
不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等  
同时也开始支持 cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可  
HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等  
但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive  
**HTTP/1.0+**  
在20世纪90年代中叶，为满足飞快发展的万维网，很多流行的 Web 客户端和服务器飞快的向 HTTP 中添加各种特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被假如到 HTTP 中，并称为非官方的事实标准。这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+  
**HTTP/1.1**  
http1.1是目前最为主流的http协议版本，从1997年发布至今，仍是主流的http协议版本。
引入了持久连接，或叫长连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。  
引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。  
新增方法：PUT、 PATCH、 OPTIONS、 DELETE。  
http协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度。  
**HTTP/2.0（又名 HTTP-NG）**  
http/2发布于2015年，目前应用还比较少。  
http/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。  
复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了队头堵塞的问题,此双向的实时通信称为多工（ Multiplexing）。  
HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。  
引入头信息压缩机制（ header compression） ,头信息使用gzip或compress压缩后再发送。     
### 10.lvs，nginx，HA在七层网络协议中分别作用于哪层，各自的区别   

> lvs:3,4 -LVS的通过控制IP来实现负载均衡。  
nginx:4,5,6,7  
HA:一种是HTTP模式，属于7层分发，另外一种是TCP模式，属于4层分发。  
### 11.tpc如何实现可靠传输(如何实现udp的可靠传输)   
> 超时重传（定时器）
> 
> 有序接受 （添加包序号）
> 
> 应答确认 （Seq/Ack应答机制）
> 
> 滑动窗口流量控制等机制 （滑动窗口协议）
### 12.tcp和udp的区别  
||TCP|	UDP|  
| --- | --- | --- |  
|连接性|	面向连接|	面向非连接|  
|传输可靠性|	可靠|	不可靠|  
|报文|	面向字节流|	面向报文| 
|效率|	传输效率低|	传输效率高|  
|流量控制|	滑动窗口|	无|  
|拥塞控制|	慢开始、拥塞避免、快重传、快恢复|	无|  
|传输速度|	慢|	快|  
|应用场合|	对效率要求低，对准确性要求高或要求有连接的场景|	对效率要求高，对准确性要求低|  

### 13.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
> 客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。
## 二.操作系统
1.线程和进程的区别(可能会问到协程)  
2.进程的调度算法  
3.linux中几种io模型(select,poll,epoll)  
4.分页，分段，段页的区别  
5.操作系统的作用和功能  
6.死锁的定义以及如何避免死锁(银行家算法)  
7.进程的通信方式  
8.线程的七态模型  
9.进程间同步与互斥的区别，线程同步的方式  
10.动态链接库与静态链接库的区别  

## 三.数据结构
1.如何检验链表是否有环  
2.常用的排序算法(算法复杂度，是否稳定，空间复杂度)  
3.二叉树和B树的区别  
4.B树和B+树的区别  
5.hashMap解决hash冲突的几种方式  
6.红黑树和平衡二叉树的区别  
7.霍夫曼编码的应用  
8.数组和链表的区别  
9.10w条数据如何找出前一百条频繁数据  
10.100个有序数列如何合成一个大数组  

## 四.java基础
1.HashMap底层原理(一定要看源码)  
2.有序集合有哪些  
3.jvm内存模型(线程私有和线程共享内存分别是什么)  
4.gc算法，垃圾收集器有哪些(g1收集器非常重要)  
5.如何控制线程并发安全  
6.线程安全的集合有哪些(各种集合类的比较，如HashTable和ConcurrentHashMap之间的区别和效率差异)  
7.java中常见的锁(乐观锁悲观锁)  
8.synchronized和lock有什么区别  
9.可重入锁和非可重入锁的区别  
10.线程池的七个参数，线程池的好处  
11.java中有哪些常用的线程池  
12.jvm类加载过程  
13.反射的原理，有什么应用  
14.java如何打破双亲委派  
15.volatile的作用  
16.线程间如何通信  
17.CAS算法以及可能产生的问题  
18.乐观锁和悲观锁的区别  
19.String，StringBuffer和StringBuilder的区别(String是不可变类有什么好处)  
20.为什么String是不可变类，有什么好处  
21.如何保证线程顺序执行  
22.sleep和wait的区别  
23.synchronized锁膨胀过程  
24.抽象类与接口的区别  
25.HashMap和HashTable的区别  
26.线程安全的数组有哪些  
27.谈谈你对面向对象的理解  
28.常用的设计模式  
29.HashMap和HashTable的区别  


## 五.MySQL数据库
1.数据库中有哪些索引类型  
2.数据库索引底层实现  
3.为什么选用B+树  
4.hash索引与B+树如何选用  
5.有哪些数据库引擎，各自的区别  
6.怎么对一条查询语句进行调优  
7.聚集索引和非聚集索引的区别  
8.MySQL有哪几种锁，分别怎么实现  
9.MySQL四种隔离引擎，底层实现  
10.什么情况下设置了索引但是会失效  
11.优化数据库的方案  
12.数据库的三大范式  
13.数据库的四大特性  
14.数据库如何解决幻读(mvcc + 间隙锁)  

## 六.Spring以及分布式知识
1.Spring的启动流程  
2.Spring Bean的注入方式  
3.Spring IOC如何实现(DefaultListAbleBeanFactory)  
4.Spring Aop如何实现，有什么作用  
5.Spring事务传播机制有哪几种  
6.Spring Bean的初始化过程  
7.Spring如何解决循环依赖  
8.Spring如何实现懒加载  
9.分布式系统如何实现数据一致性  
10.谈谈你对微服务的理解  
11.负载均衡策略有哪几种方式  
12.SOA和微服务的区别  
13.如何实现分布式锁  
14.如何手写限流算法  
15.CAP理论和base定理  
16.分布式系统需要考虑哪些问题  
17.你的系统你会从哪些方面考虑去优化  
18.你的服务挂了怎么处理  